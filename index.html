<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sleeper Trade Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="min-h-screen bg-gray-50 text-gray-900">
    <div class="p-4 text-sm text-gray-700">If this stays blank, the app failed to load. Errors will appear below.</div>
    <div id="root"></div>
    <pre id="errlog" class="m-4 p-3 bg-red-50 border border-red-200 text-red-800 text-xs rounded hidden"></pre>

    <script>
      (function(){
        function showEarly(msg){
          var el = document.getElementById('errlog');
          if (!el) return;
          el.classList.remove('hidden');
          el.textContent += String(msg) + "\n";
        }
        setTimeout(function(){
          if (!window.React) showEarly('React failed to load. Check network restrictions.');
          if (!window.ReactDOM) showEarly('ReactDOM failed to load.');
          if (!window.Babel) showEarly('Babel (standalone) failed to load.');
        }, 1500);
      })();
    </script>

    <script type="text/babel" data-presets="typescript,react">
      console.log('[GitHub] Boot script start');
      const errEl = document.getElementById('errlog');
      function showError(msg) {
        if (!errEl) return;
        errEl.classList.remove('hidden');
        errEl.textContent += (typeof msg === 'string' ? msg : JSON.stringify(msg)) + "\n";
      }
      if (errEl) { errEl.classList.remove('hidden'); errEl.textContent += 'Booting preview...\n'; }
      window.addEventListener('error', (e) => showError(e.message || e.error));
      window.addEventListener('unhandledrejection', (e) => showError(e.reason?.message || String(e.reason)));

      type SleeperLeague = { league_id: string; name: string; season: string; total_rosters: number; roster_positions: string[]; scoring_settings?: Record<string, number>; settings?: Record<string, any> };
      type SleeperUser = { user_id: string; display_name: string };
      type SleeperRoster = { roster_id: number; owner_id: string; players: string[]; taxi?: string[]; starters?: string[] };
      type SleeperPlayer = { player_id: string; first_name?: string; last_name?: string; full_name?: string; position?: string; team?: string; age?: number };

      function normalizeName(name: string): string { return name.toLowerCase().replace(/[^a-z0-9]/g, "").trim(); }
      function bestNameMatch(name: string, allNames: string[]): string | null {
        const norm = normalizeName(name);
        let best: { candidate: string; score: number } | null = null;
        for (const candidate of allNames) {
          const cNorm = normalizeName(candidate);
          let score = 0;
          for (let i = 0; i < Math.min(norm.length, cNorm.length); i++) { if (norm[i] === cNorm[i]) score++; else break; }
          if (!best || score > best.score) best = { candidate, score };
        }
        return best && best.score > 2 ? best.candidate : null;
      }

      function splitCsvLine(line: string): string[] {
        const result: string[] = [];
        let current = "";
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          const ch = line[i];
          if (ch === '"') { if (inQuotes && line[i + 1] === '"') { current += '"'; i++; } else { inQuotes = !inQuotes; } }
          else if (ch === ',' && !inQuotes) { result.push(current); current = ""; }
          else { current += ch; }
        }
        result.push(current);
        return result.map(s => s.trim());
      }

      function SleeperTradeAssistant() {
        const [leagueId, setLeagueId] = React.useState("1232275642863591424");
        const [league, setLeague] = React.useState<SleeperLeague | null>(null);
        const [users, setUsers] = React.useState<SleeperUser[]>([]);
        const [rosters, setRosters] = React.useState<SleeperRoster[]>([]);
        const [players, setPlayers] = React.useState<Record<string, SleeperPlayer>>({});
        const [loading, setLoading] = React.useState(false);
        const [error, setError] = React.useState<string | null>(null);
        const [ktcMap, setKtcMap] = React.useState<Record<string, number>>({});
        const [csvLoaded, setCsvLoaded] = React.useState(false);
        const [uploadedFileName, setUploadedFileName] = React.useState<string | null>(null);
        const fileInputRef = React.useRef<HTMLInputElement | null>(null);
        const [posFilter, setPosFilter] = React.useState<Record<string, boolean>>({ QB: true, RB: true, WR: true, TE: true });

        function togglePos(pos: string) { setPosFilter(prev => ({ ...prev, [pos]: !prev[pos] })); }
        async function fetchJSON(url: string) { const res = await fetch(url); if (!res.ok) throw new Error(`${res.status} ${res.statusText} for ${url}`); return res.json(); }

        async function loadAll() {
          setLoading(true); setError(null);
          try {
            const lg = await fetchJSON(`https://api.sleeper.app/v1/league/${leagueId}`); setLeague(lg);
            const us = await fetchJSON(`https://api.sleeper.app/v1/league/${leagueId}/users`); setUsers(us);
            const rs = await fetchJSON(`https://api.sleeper.app/v1/league/${leagueId}/rosters`); setRosters(rs);
            const ps = await fetchJSON(`https://api.sleeper.app/v1/players/nfl`); setPlayers(ps);
          } catch (e) { setError((e as any).message ?? String(e)); } finally { setLoading(false); }
        }
        React.useEffect(() => { loadAll(); }, []);

        function playerName(pid: string) { const p = players[pid]; if (!p) return pid; return p.full_name || [p.first_name, p.last_name].filter(Boolean).join(" ") || pid; }
        function playerPos(pid: string) { const p = players[pid]; return p?.position || ""; }
        function valueByName(name: string): number | undefined { return ktcMap[name.toLowerCase()]; }
        function valueByPlayerId(pid: string): number | undefined { return valueByName(playerName(pid)); }

        // CSV parsing + scaling like the app
        const [csvDebug, setCsvDebug] = React.useState(null as null | { mappedCount: number; samples: [string, number][]; fuzzy: [string, string][]; unmatched: string[] });
        function ingestFantasyProsCsv(text: string) {
          const rows = text.trim().split(/\r?\n/); if (!rows.length) return;
          const header = splitCsvLine(rows[0]).map(s => s.toLowerCase());
          const nameIdx = header.findIndex(h => h.includes("player"));
          const rankIdx = header.findIndex(h => h === "rk" || h.includes("ecr") || h.includes("overall") || h.includes("avg") || h.includes("rank"));
          const map = {} as Record<string, number>;
          const allPlayerNames = Object.values(players).map((p: any) => p.full_name || `${p.first_name} ${p.last_name}`.trim()).filter(Boolean) as string[];
          const fuzzy: [string,string][] = []; const unmatched: string[] = [];
          for (let i = 1; i < rows.length; i++) {
            const cols = splitCsvLine(rows[i]); if (cols.length <= Math.max(nameIdx, rankIdx)) continue;
            const rawName = (cols[nameIdx] || '').replace(/^"|"$/g, '').trim();
            const rank = parseFloat(String(cols[rankIdx]).replace(/[^0-9.\-]/g, ''));
            if (rawName && Number.isFinite(rank)) {
              const match = bestNameMatch(rawName, allPlayerNames) || rawName;
              if (match !== rawName) fuzzy.push([rawName, match]);
              const scaled = Math.max(1, 5000 - Math.round(10 * rank));
              map[match.toLowerCase()] = scaled;
            } else if (rawName) { unmatched.push(rawName); }
          }
          setKtcMap(map); setCsvLoaded(true);
          setCsvDebug({ mappedCount: Object.keys(map).length, samples: Object.entries(map).slice(0,20) as any, fuzzy: fuzzy.slice(0,20), unmatched: unmatched.slice(0,20) });
        }

        function handleFileUpload(e: React.ChangeEvent<HTMLInputElement>) {
          const file = e.target.files?.[0]; if (!file) return; setUploadedFileName(file.name);
          const reader = new FileReader(); reader.onload = (evt) => { const text = evt.target?.result as string; if (text) ingestFantasyProsCsv(text); };
          reader.onerror = () => setError("Failed to read file"); reader.readAsText(file);
        }
        function triggerFilePicker() { fileInputRef.current?.click(); }

        function simulateTeamAfterTrade(baseTeam: any, removePids: string[], addPids: string[]) {
          const newPlayers = new Set(baseTeam.players); removePids.forEach((pid: string) => newPlayers.delete(pid)); addPids.forEach((pid: string) => newPlayers.add(pid));
          let total = 0; const posCounts: Record<string, number> = {};
          for (const pid of newPlayers) { const v = valueByPlayerId(pid) || 0; total += v; const pos = playerPos(pid) || "NA"; posCounts[pos] = (posCounts[pos] || 0) + 1; }
          return { totalKtc: total, posCounts };
        }

        function combinations(arr: any[], k: number) { if (k === 1) return arr.map(x => [x]); const result: any[][] = []; for (let i = 0; i <= arr.length - k; i++) { const head = arr[i]; const tail = combinations(arr.slice(i + 1), k - 1); for (const t of tail) result.push([head, ...t]); } return result; }

        const teams = React.useMemo(() => {
          const nameByUser: Record<string,string> = Object.fromEntries(users.map(u => [u.user_id,(u as any).display_name]));
          return rosters.map(r => {
            const counts: Record<string,number> = {}; let total = 0;
            for (const pid of (r as any).players || []) { const pos = playerPos(pid) || "NA"; counts[pos] = (counts[pos] || 0) + 1; const v = valueByPlayerId(pid); if (v) total += v; }
            return { roster_id: (r as any).roster_id, owner_id: (r as any).owner_id, owner_name: nameByUser[(r as any).owner_id] || (r as any).owner_id, players: (r as any).players || [], posCounts: counts, totalKtc: Object.keys(ktcMap).length ? total : undefined };
          });
        }, [rosters, users, players, ktcMap]);

        const leaguePosAverages = React.useMemo(() => {
          const agg: Record<string,number> = {}; const teamCount = teams.length || 1;
          teams.forEach((t: any) => { Object.entries(t.posCounts).forEach(([pos,n]) => { agg[pos]=(agg[pos]||0)+Number(n); }); });
          const avg: Record<string,number> = {}; Object.entries(agg).forEach(([pos,total])=>{avg[pos]=Number(total)/teamCount;}); return avg;
        }, [teams]);

        const [trendingAddSet, setTrendingAddSet] = React.useState(new Set<string>());
        const [trendingDropSet, setTrendingDropSet] = React.useState(new Set<string>());
        React.useEffect(() => {
          async function loadTrending(){
            try {
              const lookback = 72, limit = 200;
              const [adds, drops] = await Promise.all([
                fetchJSON(`https://api.sleeper.app/v1/players/nfl/trending/add?lookback_hours=${lookback}&limit=${limit}`),
                fetchJSON(`https://api.sleeper.app/v1/players/nfl/trending/drop?lookback_hours=${lookback}&limit=${limit}`),
              ]);
              setTrendingAddSet(new Set(adds.map((a:any)=>a.player_id)));
              setTrendingDropSet(new Set(drops.map((d:any)=>d.player_id)));
            } catch(e) { console.warn('Failed to load trending players', e); }
          }
          if (players && Object.keys(players).length) loadTrending();
        }, [players]);

        const tradeFits = React.useMemo(() => {
          if (!teams.length || !csvLoaded) return [] as any[];
          const fits: any[] = []; const positions = ["QB","RB","WR","TE"];
          function surplusDelta(team: any, pos: string){ return (team.posCounts[pos] || 0) - (leaguePosAverages[pos] || 0); }
          function playerVal(pid: string){ return valueByPlayerId(pid) || 0; }
          for (let i = 0; i < teams.length; i++) {
            for (let j = i + 1; j < teams.length; j++) {
              const A = teams[i], B = teams[j];
              positions.forEach(pA => { if (!posFilter[pA]) return; const aSurplus = surplusDelta(A, pA); if (aSurplus <= 0) return;
                positions.forEach(pB => { if (!posFilter[pB]) return; const aNeed = surplusDelta(A, pB) < 0; const bSurplus = surplusDelta(B, pB) > 0; const bNeed = surplusDelta(B, pA) < 0; if (!(aNeed && bSurplus && bNeed)) return;
                  const aPlayers = A.players.filter((pid:string) => playerPos(pid) === pA);
                  const bPlayers = B.players.filter((pid:string) => playerPos(pid) === pB);
                  const combosA = [...combinations(aPlayers, 1), ...combinations(aPlayers, 2)];
                  const combosB = [...combinations(bPlayers, 1), ...combinations(bPlayers, 2)];
                  for (const give of combosA) {
                    for (const get of combosB) {
                      if (give.length === 2 && get.length === 2) continue;
                      if (give.some((pid:string)=>!playerVal(pid)) || get.some((pid:string)=>!playerVal(pid))) continue;
                      const giveValue = give.reduce((s:number, pid:string)=>s+playerVal(pid),0);
                      const getValue = get.reduce((s:number, pid:string)=>s+playerVal(pid),0);
                      if (!giveValue || !getValue) continue;
                      const ratio = giveValue / getValue;
                      if (ratio >= 0.95 && ratio <= 1.05) {
                        const anyTrending = [...give, ...get].some((pid:string)=>trendingAddSet.has(pid) || trendingDropSet.has(pid));
                        fits.push({ fromTeam: A, toTeam: B, givePids: give, getPids: get, givePlayers: give.map(playerName), getPlayers: get.map(playerName), giveValue, getValue, fairnessScore: Math.abs(1 - ratio), rationale: `A surplus at ${pA}, needs ${pB}; B surplus at ${pB}, needs ${pA}`, includesTrending: anyTrending, ratio });
                      }
                    }
                  }
                });
              });
            }
          }
          const uniq = new Map<string, any>();
          for (const f of fits) {
            const left = `${f.fromTeam.roster_id}:${[...f.givePlayers].sort().join("|")}`;
            const right = `${f.toTeam.roster_id}:${[...f.getPlayers].sort().join("|")}`;
            const key = [left, right].sort().join("::");
            if (!uniq.has(key)) uniq.set(key, f);
          }
          return Array.from(uniq.values()).sort((a, b) => {
            if (a.includesTrending !== b.includesTrending) return a.includesTrending ? -1 : 1;
            if (a.fairnessScore !== b.fairnessScore) return a.fairnessScore - b.fairnessScore;
            const aTotal = a.giveValue + a.getValue; const bTotal = b.giveValue + b.getValue; return bTotal - aTotal;
          }).slice(0, 50);
        }, [teams, leaguePosAverages, ktcMap, posFilter, csvLoaded, trendingAddSet, trendingDropSet]);

        const teamValueByPos = React.useMemo(() => {
          const byTeam: Record<number, { posValues: Record<string, number>; total: number }> = {};
          for (const t of teams as any) {
            const posValues: Record<string, number> = {}; let total = 0;
            for (const pid of t.players) { const v = valueByPlayerId(pid) || 0; const pos = playerPos(pid) || "NA"; posValues[pos] = (posValues[pos] || 0) + v; total += v; }
            byTeam[(t as any).roster_id] = { posValues, total };
          }
          return byTeam;
        }, [teams, ktcMap, players]);

        const leaguePosValueAverages = React.useMemo(() => {
          const agg: Record<string, number> = {};
          for (const t of teams as any) { for (const pid of t.players) { const v = valueByPlayerId(pid) || 0; const pos = playerPos(pid) || "NA"; agg[pos] = (agg[pos] || 0) + v; } }
          const avg: Record<string, number> = {}; const teamCount = (teams as any).length || 1;
          Object.entries(agg).forEach(([pos, total]) => { (avg as any)[pos] = (total as number) / teamCount; });
          return avg;
        }, [teams, ktcMap, players]);

        function ImpactPreview({ team, removePids, addPids }: { team: any; removePids: string[]; addPids: string[] }) {
          const beforeTotal = (team.totalKtc ?? (teamValueByPos as any)[team.roster_id]?.total ?? 0) as number;
          const after = simulateTeamAfterTrade(team, removePids, addPids);
          const delta = Math.round((after.totalKtc || 0) - beforeTotal);
          const posList = ["QB","RB","WR","TE"];
          return (
            <div className="text-xs text-gray-700">
              <div>Value: {Math.round(beforeTotal)} → {Math.round(after.totalKtc)} ({delta >= 0 ? "+" : ""}{delta})</div>
              <div className="mt-1 flex flex-wrap gap-2">
                {posList.map(pos => (
                  <span key={pos} className="px-2 py-0.5 rounded bg-gray-50 border">{pos}: {(team.posCounts[pos]||0)} → {(after.posCounts[pos]||0)}</span>
                ))}
              </div>
            </div>
          );
        }

        return (
          <div className="min-h-screen bg-gray-50 text-gray-900 p-6">
            <div className="max-w-6xl mx-auto">
              <h1 className="text-3xl md:text-4xl font-bold mb-2">Sleeper Trade Assistant</h1>
              <p className="text-sm text-gray-600 mb-6">Analyze your Sleeper league and get trade suggestions powered by FantasyPros rankings.</p>

              <div className="flex gap-3 mb-6 items-center">
                <input type="text" value={leagueId} onChange={(e)=>setLeagueId((e.target as HTMLInputElement).value)} placeholder="Enter Sleeper League ID" className="border rounded-lg px-3 py-2 text-sm" />
                <button className="px-3 py-2 rounded bg-blue-600 text-white" onClick={loadAll}>Load League</button>
                <input ref={fileInputRef} type="file" accept=".csv" onChange={handleFileUpload} className="hidden" />
                <button className="px-3 py-2 rounded bg-gray-200" onClick={()=>fileInputRef.current?.click()}>Upload FantasyPros CSV</button>
                {uploadedFileName && <span className="text-sm text-gray-600">Loaded: {uploadedFileName}</span>}
              </div>

              <div className="flex gap-4 mb-6">
                {Object.keys(posFilter).map(pos => (
                  <label key={pos} className="flex items-center gap-1 text-sm">
                    <input type="checkbox" checked={!!(posFilter as any)[pos]} onChange={() => togglePos(pos)} />
                    {pos}
                  </label>
                ))}
              </div>

              {league && (
                <div className="bg-white rounded-2xl shadow p-4 mb-6">
                  <h2 className="text-xl font-semibold mb-2">League Info</h2>
                  <div className="text-sm text-gray-700">{(league as any).name} ({(league as any).season})</div>
                  {csvLoaded && <div className="text-xs text-green-600 mt-1">FantasyPros CSV initialized</div>}
                  {csvDebug && (
                    <details className="mt-3 text-xs">
                      <summary className="cursor-pointer font-medium">CSV Debug</summary>
                      <div className="mt-2 grid grid-cols-1 md:grid-cols-3 gap-3">
                        <div className="border rounded-lg p-2">
                          <div className="font-semibold mb-1">Mapped</div>
                          <div className="text-gray-700">Total: {(csvDebug as any).mappedCount}</div>
                          <div className="mt-1 max-h-40 overflow-auto">
                            {(csvDebug as any).samples.map(([n,v]: any) => (
                              <div key={n} className="flex justify-between gap-2"><span className="truncate">{n}</span><span>{Math.round(v)}</span></div>
                            ))}
                          </div>
                        </div>
                        <div className="border rounded-lg p-2">
                          <div className="font-semibold mb-1">Fuzzy Matches</div>
                          <div className="mt-1 max-h-40 overflow-auto">
                            {(csvDebug as any).fuzzy.length ? (csvDebug as any).fuzzy.map(([raw,match]: any) => (
                              <div key={raw} className="flex justify-between gap-2"><span className="truncate">{raw}</span><span className="truncate">→ {match}</span></div>
                            )) : <div className="text-gray-500">None</div>}
                          </div>
                        </div>
                        <div className="border rounded-lg p-2">
                          <div className="font-semibold mb-1">Unmatched</div>
                          <div className="mt-1 max-h-40 overflow-auto">
                            {(csvDebug as any).unmatched.length ? (csvDebug as any).unmatched.map((raw: any) => (
                              <div key={raw} className="truncate">{raw}</div>
                            )) : <div className="text-gray-500">None</div>}
                          </div>
                        </div>
                      </div>
                    </details>
                  )}
                </div>
              )}

              <div className="grid gap-4 md:grid-cols-2">
                <div className="bg-white rounded-2xl shadow p-4">
                  <h2 className="text-xl font-semibold mb-3">Teams & Positional Depth</h2>
                  {(teams as any).map((t:any) => (
                    <div key={t.roster_id} className="border rounded-xl p-3 mb-2">
                      <div className="font-semibold flex justify-between"><span>{t.owner_name}</span>{t.totalKtc && <span>Total Value: {Math.round(t.totalKtc)}</span>}</div>
                      <div className="mt-2 text-sm flex flex-wrap gap-2">
                        {Object.entries(t.posCounts).map(([pos, n]: any) => <span key={pos} className="px-2 py-1 rounded-full bg-gray-100">{pos}: {n}</span>)}
                      </div>
                    </div>
                  ))}
                </div>

                <div className="bg-white rounded-2xl shadow p-4">
                  <h2 className="text-xl font-semibold mb-3">Suggested Trades</h2>
                  {(teams as any).length && csvLoaded ? (
                    (tradeFits as any).map((fit:any, idx:number) => (
                      <details key={idx} className="border rounded-xl p-3 mb-2">
                        <summary className="cursor-pointer flex justify-between items-center">
                          <span className="font-semibold">{fit.fromTeam.owner_name} ➜ {fit.toTeam.owner_name}</span>
                          <span className="text-xs text-gray-500">Fairness Ratio: {fit.ratio.toFixed(2)} | Total Value: {Math.round(fit.giveValue + fit.getValue)}{fit.includesTrending ? " · Trending" : ""}</span>
                        </summary>
                        <div className="mt-2 text-sm">
                          <div className="mt-2 flex flex-col gap-2">
                            <div className="flex items-center gap-2 flex-wrap">
                              <span className="text-sm font-semibold">Give:</span>
                              {fit.givePlayers.map((name:string) => (
                                <div key={name} className="flex items-center gap-1 bg-gray-50 px-2 py-1 rounded-xl border"><span className="text-xs">{name}</span></div>
                              ))}
                            </div>
                            <div className="flex items-center gap-2 flex-wrap">
                              <span className="text-sm font-semibold">Get:</span>
                              {fit.getPlayers.map((name:string) => (
                                <div key={name} className="flex items-center gap-1 bg-gray-50 px-2 py-1 rounded-xl border"><span className="text-xs">{name}</span></div>
                              ))}
                            </div>
                          </div>
                          <div className="text-xs text-gray-500">{fit.rationale}</div>
                          <div className="mt-2 text-xs text-gray-600">Value: {fit.giveValue} vs {fit.getValue}</div>
                        </div>
                      </details>
                    ))
                  ) : (
                    <div className="text-sm text-gray-600">No balanced trades found yet. Load league + upload rankings CSV.</div>
                  )}
                </div>
              </div>

              {loading && <div className="mt-4 text-sm text-gray-600">Loading...</div>}
              {error && <div className="mt-4 text-sm text-red-600">Error: {String(error)}</div>}
            </div>
          </div>
        );
      }

      try {
        const rootNode = document.getElementById('root');
        if (!rootNode) throw new Error('Root node not found');
        const root = (ReactDOM as any).createRoot ? (ReactDOM as any).createRoot(rootNode) : (ReactDOM as any).render;
        if ((ReactDOM as any).createRoot) { (root as any).render(<SleeperTradeAssistant />); }
        else { (ReactDOM as any).render(<SleeperTradeAssistant />, rootNode); }
        console.log('[GitHub] Rendered');
      } catch (e) {
        showError(e instanceof Error ? e.message : String(e));
        console.error(e);
      }
    </script>
  </body>
  </html>


